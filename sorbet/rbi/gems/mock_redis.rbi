# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/mock_redis/all/mock_redis.rbi
#
# mock_redis-0.31.0

class MockRedis
  def _parse_options(options); end
  def call(command, &_block); end
  def client; end
  def connect; end
  def db; end
  def host; end
  def id; end
  def initialize(*args); end
  def initialize_copy(source); end
  def location; end
  def logger; end
  def logging(commands); end
  def method_missing(method, *args, &block); end
  def options; end
  def port; end
  def reconnect; end
  def respond_to?(method, include_private = nil); end
  def self.connect(*args); end
  def time_at(timestamp); end
  include MockRedis::UndefRedisMethods
end
module MockRedis::Assertions
  def assert_has_args(args, command); end
end
class MockRedis::WouldBlock < StandardError
end
module MockRedis::UtilityMethods
  def clean_up_empties_at(key); end
  def common_scan(values, cursor, opts = nil); end
  def left_pad(str, size); end
  def primitive?(value); end
  def twos_complement_decode(array); end
  def twos_complement_encode(n, size); end
  def with_thing_at(key, assertion, empty_thing_generator); end
end
module MockRedis::HashMethods
  def assert_hashy(key); end
  def hashy?(key); end
  def hdel(key, *fields); end
  def hexists(key, field); end
  def hget(key, field); end
  def hgetall(key); end
  def hincrby(key, field, increment); end
  def hincrbyfloat(key, field, increment); end
  def hkeys(key); end
  def hlen(key); end
  def hmget(key, *fields); end
  def hmset(key, *kvpairs); end
  def hscan(key, cursor, opts = nil); end
  def hscan_each(key, opts = nil, &block); end
  def hset(key, *args); end
  def hsetnx(key, field, value); end
  def hvals(key); end
  def mapped_hmget(key, *fields); end
  def mapped_hmset(key, hash); end
  def with_hash_at(key, &blk); end
  include MockRedis::Assertions
  include MockRedis::UtilityMethods
end
module MockRedis::ListMethods
  def assert_listy(key); end
  def blpop(*args); end
  def brpop(*args); end
  def brpoplpush(source, destination, options = nil); end
  def first_nonempty_list(keys); end
  def lindex(key, index); end
  def linsert(key, position, pivot, value); end
  def list_at?(key); end
  def listy?(key); end
  def llen(key); end
  def lpop(key); end
  def lpush(key, values); end
  def lpushx(key, value); end
  def lrange(key, start, stop); end
  def lrem(key, count, value); end
  def lset(key, index, value); end
  def ltrim(key, start, stop); end
  def rpop(key); end
  def rpoplpush(source, destination); end
  def rpush(key, values); end
  def rpushx(key, value); end
  def with_list_at(key, &blk); end
  include MockRedis::Assertions
  include MockRedis::UtilityMethods
end
module MockRedis::SetMethods
  def assert_sety(key); end
  def sadd(key, members); end
  def scard(key); end
  def sdiff(*keys); end
  def sdiffstore(destination, *keys); end
  def sety?(key); end
  def sinter(*keys); end
  def sinterstore(destination, *keys); end
  def sismember(key, member); end
  def smembers(key); end
  def smove(src, dest, member); end
  def spop(key, count = nil); end
  def srandmember(key, count = nil); end
  def srem(key, members); end
  def sscan(key, cursor, opts = nil); end
  def sscan_each(key, opts = nil, &block); end
  def sunion(*keys); end
  def sunionstore(destination, *keys); end
  def with_set_at(key, &blk); end
  def with_sets_at(*keys, &blk); end
  include MockRedis::Assertions
  include MockRedis::UtilityMethods
end
module MockRedis::StringMethods
  def append(key, value); end
  def assert_stringy(key, message = nil); end
  def bitcount(key, start = nil, stop = nil); end
  def bitfield(*args); end
  def decr(key); end
  def decrby(key, n); end
  def get(key); end
  def getbit(key, offset); end
  def getrange(key, start, stop); end
  def getset(key, value); end
  def incr(key); end
  def incr_bitfield(val, incrby, is_signed, type_size, overflow_method); end
  def incrby(key, n); end
  def incrbyfloat(key, n); end
  def mapped_mget(*keys); end
  def mapped_mset(hash); end
  def mapped_msetnx(hash); end
  def mget(*keys, &blk); end
  def mset(*kvpairs); end
  def msetnx(*kvpairs); end
  def set(key, value, ex: nil, px: nil, nx: nil, xx: nil, keepttl: nil); end
  def set_bitfield(key, value, is_signed, type_size, offset); end
  def setbit(key, offset, value); end
  def setex(key, seconds, value); end
  def setnx(key, value); end
  def setrange(key, offset, value); end
  def stringy?(key); end
  def strlen(key); end
  include MockRedis::Assertions
  include MockRedis::UtilityMethods
end
class MockRedis::Zset
  def add(score, member); end
  def delete?(member); end
  def each; end
  def empty?(*args, &block); end
  def in_range(min, max); end
  def include?(*args, &block); end
  def initialize; end
  def initialize_copy(source); end
  def intersection(other); end
  def members; end
  def score(member); end
  def scores; end
  def size(*args, &block); end
  def sorted; end
  def sorted_members; end
  def union(other); end
  extend Forwardable
  include Enumerable
end
module MockRedis::ZsetMethods
  def apply_limit(collection, limit); end
  def assert_coercible_zsety(key); end
  def assert_range_args(min, max); end
  def assert_scorey(value, message = nil); end
  def assert_zsety(key); end
  def coerce_to_zset(set); end
  def coercible_zsety?(key); end
  def combine_weighted_zsets(keys, options, how); end
  def looks_like_float?(x); end
  def to_response(score_member_pairs, options); end
  def with_zset_at(key, coercible: nil, &blk); end
  def with_zsets_at(*keys, coercible: nil, &blk); end
  def zadd(key, *args); end
  def zadd_multiple_members(key, args, zadd_options = nil); end
  def zadd_one_member(key, score, member, zadd_options = nil); end
  def zcard(key); end
  def zcount(key, min, max); end
  def zincrby(key, increment, member); end
  def zinterstore(destination, keys, options = nil); end
  def zpopmax(key, count = nil); end
  def zpopmin(key, count = nil); end
  def zrange(key, start, stop, options = nil); end
  def zrangebyscore(key, min, max, options = nil); end
  def zrank(key, member); end
  def zrem(key, *args); end
  def zremrangebyrank(key, start, stop); end
  def zremrangebyscore(key, min, max); end
  def zrevrange(key, start, stop, options = nil); end
  def zrevrangebyscore(key, max, min, options = nil); end
  def zrevrank(key, member); end
  def zscan(key, cursor, opts = nil); end
  def zscan_each(key, opts = nil, &block); end
  def zscore(key, member); end
  def zsety?(key); end
  def zunionstore(destination, keys, options = nil); end
  include MockRedis::Assertions
  include MockRedis::UtilityMethods
end
module MockRedis::SortMethod
  def lookup_from_pattern(pattern, element); end
  def project(enumerable, by, get_patterns); end
  def slice(sorted, limit); end
  def sort(key, options = nil); end
  def sort_by(projected, direction); end
  include MockRedis::Assertions
end
class MockRedis::IndifferentHash < Hash
  def has_key?(key); end
  def key?(key); end
end
module MockRedis::InfoMethod
  def info(section = nil); end
end
module MockRedis::GeospatialMethods
  def calculate_approximate_area(hash, lng_range, lat_range); end
  def deg_rad(ang); end
  def deinterleave(bits); end
  def format_decoded_coord(coord); end
  def geoadd(key, *args); end
  def geodist(key, member1, member2, unit = nil); end
  def geohash(key, members); end
  def geohash_decode(hash, lng_range = nil, lat_range = nil); end
  def geohash_distance(lng1d, lat1d, lng2d, lat2d); end
  def geohash_encode(lng, lat, lng_range = nil, lat_range = nil, step = nil); end
  def geopos(key, members); end
  def interleave(x, y); end
  def parse_point(point); end
  def parse_points(args); end
  def parse_unit(unit); end
  def rad_deg(ang); end
end
class MockRedis::Stream
  def add(id, values); end
  def each; end
  def empty?(*args, &block); end
  def initialize; end
  def last_id; end
  def members; end
  def members=(arg0); end
  def options(opts_in, permitted); end
  def range(start, finish, reversed, *opts_in); end
  def read(id, *opts_in); end
  def trim(count); end
  extend Forwardable
  include Enumerable
end
class MockRedis::Stream::Id
  def <=>(other); end
  def exclusive; end
  def exclusive=(arg0); end
  def initialize(id, min: nil, sequence: nil); end
  def sequence; end
  def sequence=(arg0); end
  def timestamp; end
  def timestamp=(arg0); end
  def to_s; end
  include Comparable
end
module MockRedis::StreamMethods
  def assert_streamy(key); end
  def streamy?(key); end
  def with_stream_at(key, &blk); end
  def xadd(key, entry, opts = nil); end
  def xlen(key); end
  def xrange(key, first = nil, last = nil, count: nil); end
  def xread(keys, ids, count: nil, block: nil); end
  def xrevrange(key, last = nil, first = nil, count: nil); end
  def xtrim(key, count); end
  include MockRedis::Assertions
  include MockRedis::UtilityMethods
end
module MockRedis::ConnectionMethod
  def connection; end
end
class MockRedis::Database
  def assert_valid_integer(integer); end
  def assert_valid_timeout(timeout); end
  def auth(_); end
  def bgrewriteaof; end
  def bgsave; end
  def can_incr?(value); end
  def can_incr_float?(value); end
  def close; end
  def connected?; end
  def data; end
  def dbsize; end
  def del(*keys); end
  def disconnect!; end
  def disconnect; end
  def dump(key); end
  def echo(msg); end
  def eval(*args); end
  def evalsha(*args); end
  def exists(*keys); end
  def exists?(*keys); end
  def expiration(key); end
  def expire(key, seconds); end
  def expire_keys; end
  def expire_times; end
  def expireat(key, timestamp); end
  def extract_timeout(arglist); end
  def flushdb; end
  def has_expiration?(key); end
  def initialize(base, *_args); end
  def initialize_copy(_source); end
  def keys(format = nil); end
  def lastsave; end
  def looks_like_float?(str); end
  def looks_like_integer?(str); end
  def now; end
  def persist(key); end
  def pexpire(key, ms); end
  def pexpireat(key, timestamp_ms); end
  def ping(response = nil); end
  def pttl(key); end
  def quit; end
  def randomkey; end
  def redis_pattern_to_ruby_regex(pattern); end
  def remove_expiration(key); end
  def rename(key, newkey); end
  def renamenx(key, newkey); end
  def restore(key, ttl, value, replace: nil); end
  def save; end
  def scan(cursor, opts = nil); end
  def scan_each(opts = nil, &block); end
  def script(subcommand, *args); end
  def set_expiration(key, time); end
  def time; end
  def ttl(key); end
  def type(key); end
  def unlink(*keys); end
  def zero_pad(string, desired_length); end
  include MockRedis::ConnectionMethod
  include MockRedis::GeospatialMethods
  include MockRedis::HashMethods
  include MockRedis::InfoMethod
  include MockRedis::ListMethods
  include MockRedis::SetMethods
  include MockRedis::SortMethod
  include MockRedis::StreamMethods
  include MockRedis::StringMethods
  include MockRedis::UtilityMethods
  include MockRedis::ZsetMethods
end
module MockRedis::UndefRedisMethods
  def self.included(klass); end
end
class MockRedis::ExpireWrapper
  def initialize(db); end
  def initialize_copy(source); end
  def method_missing(method, *args, &block); end
  def respond_to?(method, include_private = nil); end
  include MockRedis::UndefRedisMethods
end
class MockRedis::FutureNotReady < RuntimeError
end
class MockRedis::Future
  def block; end
  def command; end
  def initialize(command, block = nil); end
  def store_result(result); end
  def value; end
end
class MockRedis::MultiDbWrapper
  def current_db; end
  def db(index); end
  def flushall; end
  def initialize(db); end
  def initialize_copy(source); end
  def method_missing(method, *args, &block); end
  def move(key, db_index); end
  def respond_to?(method, include_private = nil); end
  def select(db_index); end
  include MockRedis::UndefRedisMethods
end
class MockRedis::PipelinedWrapper
  def in_pipeline?; end
  def initialize(db); end
  def initialize_copy(source); end
  def method_missing(method, *args, &block); end
  def pipelined(_options = nil); end
  def respond_to?(method, include_private = nil); end
  include MockRedis::UndefRedisMethods
end
class MockRedis::TransactionWrapper
  def discard; end
  def exec; end
  def in_multi?; end
  def initialize(db); end
  def initialize_copy(source); end
  def method_missing(method, *args, &block); end
  def multi; end
  def pipelined; end
  def pop_multi; end
  def push_multi; end
  def respond_to?(method, include_private = nil); end
  def unwatch; end
  def watch(*_); end
  include MockRedis::UndefRedisMethods
end
